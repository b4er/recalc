{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Recalc is a work-in-progress spreadsheet engine built in Haskell. It provides a DSL for for experimenting with functional spreadsheet languages. It includes a frontend as VS Code Extension built using the Univer Sheet API : The DSL allows custom languages and automatically provides features such as: Cell Diagnostics Sheet-Defined Functions Function Explorer cross-sheet references, etc. The Web Extension includes a dependently typed functional programming language (described here ).","title":"Introduction"},{"location":"#introduction","text":"Recalc is a work-in-progress spreadsheet engine built in Haskell. It provides a DSL for for experimenting with functional spreadsheet languages. It includes a frontend as VS Code Extension built using the Univer Sheet API : The DSL allows custom languages and automatically provides features such as: Cell Diagnostics Sheet-Defined Functions Function Explorer cross-sheet references, etc. The Web Extension includes a dependently typed functional programming language (described here ).","title":"Introduction"},{"location":"backend/","text":"Backend (Haskell) The main application for the backend follows the design of the Haskell Language Server (reactor pattern), it is built using a generic way of handling JSON-RPC inspired by Servant's named routes. At the core of the backend is the recalculation engine based on build 1 . It is responsible for handling incremental recomputations and dependency tracking for languages implementing the Recalc interface. Its main function is recalc , used by: The Recalc.Repl driver (used for tests) The Recalc.Univer driver which provides a convenience function univerMain The latter will run a language server which implements the protocol understood by the frontend. Packages recalc-engine : The core recalculation engine, includes a (preliminary) implementation for a dependency map, the document store (keeping track of files and their sheets). It defines the Recalc interfaces and provides the Fetch monad. recalc-server : A generic implementation for named handlers (from Servant-like protocol definition 2 ) of JSON-RPC for generic running language servers. recalc-univer : A generic backend implementation for a language server talking to the Univer frontend. It deals with dispatching the right operations and implements the Univer.Protocol . Andrey Mokhov, Neil Mitchell, Simon Peyton Jones. Build Systems \u00e0 la Carte . \u21a9 For more details refer to the blog post Named Routes in Servant \u21a9","title":"Backend"},{"location":"backend/#backend-haskell","text":"The main application for the backend follows the design of the Haskell Language Server (reactor pattern), it is built using a generic way of handling JSON-RPC inspired by Servant's named routes. At the core of the backend is the recalculation engine based on build 1 . It is responsible for handling incremental recomputations and dependency tracking for languages implementing the Recalc interface. Its main function is recalc , used by: The Recalc.Repl driver (used for tests) The Recalc.Univer driver which provides a convenience function univerMain The latter will run a language server which implements the protocol understood by the frontend.","title":"Backend (Haskell)"},{"location":"backend/#packages","text":"recalc-engine : The core recalculation engine, includes a (preliminary) implementation for a dependency map, the document store (keeping track of files and their sheets). It defines the Recalc interfaces and provides the Fetch monad. recalc-server : A generic implementation for named handlers (from Servant-like protocol definition 2 ) of JSON-RPC for generic running language servers. recalc-univer : A generic backend implementation for a language server talking to the Univer frontend. It deals with dispatching the right operations and implements the Univer.Protocol . Andrey Mokhov, Neil Mitchell, Simon Peyton Jones. Build Systems \u00e0 la Carte . \u21a9 For more details refer to the blog post Named Routes in Servant \u21a9","title":"Packages"},{"location":"build/","text":"Building with Nix Setup Nix (flakes) Recalc uses Nix for reproducible builds, install it if you haven't: sh <(curl -L https://nixos.org/nix/install) --daemon Enable Nix flakes by setting: nix.settings.experimental-features = [ \"nix-command\" \"flakes\" ]; Build To build, simply clone and build with Nix: git clone https://github.com/b4er/recalc.git && cd recalc nix build There should now be a symlink to the build outputs ./result .","title":"Building from Source"},{"location":"build/#building-with-nix","text":"","title":"Building with Nix"},{"location":"build/#setup-nix-flakes","text":"Recalc uses Nix for reproducible builds, install it if you haven't: sh <(curl -L https://nixos.org/nix/install) --daemon Enable Nix flakes by setting: nix.settings.experimental-features = [ \"nix-command\" \"flakes\" ];","title":"Setup Nix (flakes)"},{"location":"build/#build","text":"To build, simply clone and build with Nix: git clone https://github.com/b4er/recalc.git && cd recalc nix build There should now be a symlink to the build outputs ./result .","title":"Build"},{"location":"core/","text":"Core Language (modulo changes, new features and bugs) The provided core language (see Recalc.Language ) implements a simple, dependently typed functional programming language based on LambdaPi 1 , which is extended by cell references (sized, nested multi-dimensional arrays), and implicit arguments. Syntax Cell references and ranges are similar to Excel: \\begin{aligned} \\mathfrak{m} \\ \\mathrel{::=} & 1 \\mid 2 \\mid \\dots \\\\ \\mathfrak{n} \\ \\mathrel{::=} & \\text{A} \\mid \\text{B} \\mid \\dots \\mid \\text{AA} \\mid \\dots \\\\ \\alpha \\ \\mathrel{::=} & \\ \\mathfrak{n}\\ \\mathfrak{m} \\mid \\mathfrak{n}\\ \\mathfrak{m}\\ \\textbf{:}\\ \\mathfrak{n}\\ \\mathfrak{m} \\\\ \\\\ \\textit{sheet-id} \\ \\mathrel{::=} & \\ \\textit{simple-sheet-name} \\\\ \\mid & \\ \\texttt{'} \\textit{sheet-name} \\texttt{'} \\\\ \\mid & \\ \\texttt{[}\\ \\textit{simple-uri}\\ \\texttt{]} \\textit{simple-sheet-name} \\\\ \\mid & \\ \\texttt{'[}\\ \\textit{uri}\\ \\texttt{]} \\textit{sheet-name} \\texttt{'} \\\\ \\\\ \\xi \\ \\mathrel{::=} & \\ \\Bigl[\\textit{sheet-id}\\ \\textbf{!}\\Bigr]\\ \\alpha \\end{aligned} Where \\textit{uri} and \\textit{sheet-name} must be printable, and characters '[]\\ need to be escaped with \\ . The corresponding \\textit{simple-} prefixed versions may only contain alphanumeric characters and ._~ . When \\textit{sheet-id} is not (or partially) provided, it is implicitly defined as the \\textit{uri} and/or \\textit{sheet-name} of the location where it is being read. Terms and types share the syntax of a standard lambda calculus with dependent functions: \\begin{array}{ll} \\text{f}, \\text{x}, \\sigma, \\tau & \\mathrel{::=} & \\textit{literal} & \\color{grey}{\\text{-- decimals and Boolean values}} \\\\ & \\mid & \\text{v} & \\color{grey}{\\text{-- variables}} \\\\ & \\mid & \\texttt{\\\\} \\text{v}\\ \\texttt{->}\\ \\text{x} & \\color{grey}{\\text{-- lambda abstraction}} \\\\ & \\mid & \\texttt{*} & \\color{grey}{\\text{-- kind of types}} \\\\ & \\mid & \\texttt{(} \\text{v}\\texttt{:}\\ \\sigma \\texttt{) -> } \\tau & \\color{grey}{\\text{-- dependent function type}} \\\\ & \\mid & \\texttt{\\{} \\text{v}\\texttt{:}\\ \\sigma \\texttt{\\} -> } \\tau & \\color{grey}{\\text{-- implicit dependent function type}} \\\\ & \\mid & \\xi & \\color{grey}{\\text{-- cell reference}} \\\\ & \\mid & \\text{f(x}_1, \\dots\\text{)} & \\color{grey}{\\text{-- application}} \\\\ & \\mid & \\text{f\\{x}_1, \\dots\\text{\\}} & \\color{grey}{\\text{-- explicit application of an implicit argument}} \\end{array} where \\textit{literal} includes signed decimals, int , bool , false , and true . Identifiers are case-insensitive. When a function type ignores its argument it can be written as \\sigma \\texttt{ -> } \\tau and similarly \\text{\\{}\\sigma\\text{\\}} \\texttt{ -> } \\tau for implicit arguments. Typechecking and Inference The typing judgements and evaluation rules follow directly the LambdaPi implementation (a simple bi-directional typechecker). The only notable difference is that we introduce another context \\sigma which gives the type \\sigma_T(\\xi) and value \\sigma_V(\\xi) of a cell. The original rules are trivially extended, passing the additional \\sigma around. For example, the rule \\small{\\text{CHK}} would be extended as follows: \\begin{array}{c} \\Gamma, \\sigma\\ \\vdash\\ e\\ ::_{\\uparrow}\\ \\tau \\\\ \\hline \\Gamma, \\sigma\\ \\vdash\\ e\\ ::_{\\downarrow}\\ \\tau \\end{array} Cell References Rules concerning cell references and cell ranges make use of the new type constructor \\text{<}..\\text{>[}\\tau\\text{]} for tensors (not part of the surface language) and are quite simple: \\begin{array}{c} \\sigma_T(\\textit{sheet-id}\\ \\textbf{!}\\ \\mathfrak{n}\\ \\mathfrak{m}) = \\tau \\\\ \\hline \\Gamma, \\sigma\\ \\vdash\\ \\textit{sheet-id}\\ \\textbf{!}\\ \\mathfrak{n}\\ \\mathfrak{m}\\ ::_{\\uparrow}\\ \\tau \\end{array} \\begin{array}{c} \\sigma_T(\\textit{sheet-id}\\ \\textbf{!}\\ \\mathfrak{n}\\ \\mathfrak{m}) = \\tau \\\\ \\forall i j. (i,j) \\in \\mathfrak{n}\\ \\mathfrak{m}\\ \\textbf{:}\\ \\mathfrak{n}'\\ \\mathfrak{m}' \\implies \\sigma_T(\\textit{sheet-id}\\ \\textbf{!} (i,j)) = \\tau \\\\ m = \\mathfrak{m}' - \\mathfrak{m} \\land n = \\mathfrak{n}' - \\mathfrak{n} \\\\ dims = \\text{inferDimensions}(m, n, \\tau) \\\\ \\hline \\Gamma, \\sigma \\ \\vdash\\ \\textit{sheet-id}\\ \\textbf{!}\\ \\mathfrak{n}\\ \\mathfrak{m}\\ \\textbf{:}\\ \\mathfrak{n}'\\ \\mathfrak{m}' ::_{\\uparrow} \\text{<}dims\\text{>}\\lfloor\\tau\\rfloor \\end{array} The first one just states that a simple cell reference has the same type as the type of the term at that location. The second one is similar. Using the top left corner of a selection it makes sure that all cells in the referred range share that type \\tau . The type of a cell range is a tensor with elements \\lfloor\\tau\\rfloor . (where \\lfloor\\_\\rfloor is an identity for all types except tensor types \\text{<}..\\text{>[}\\tau'\\text{]} for which it is defined as \\tau' ) The dimensions of the resulting tensor are given by \\text{inferDimensions}(m,n,\\tau) \\mathrel{::=} \\begin{cases} n, \\text{dim}(\\tau) & \\text{if }m = 1, \\\\ m, \\text{dim}(\\tau) & \\text{if }n = 1, \\\\ m, n, \\text{dim}(\\tau) & \\text{otherwise}. \\end{cases} \\text{dim}(\\tau) \\mathrel{::=} \\begin{cases} \\bar{d} & \\text{if }\\tau\\text{ has shape <}\\bar{d}\\text{>[}\\tau'\\text{]}, \\\\ \\small{\\text{[ ]}} & \\text{otherwise}. \\end{cases} That is, referring to an m \\times n range of cells gives a tensor which potentially can become higher order when the elements are tensors by themselves. Implicit Arguments Implicit arguments are covered by \\begin{array}{c} \\Gamma, \\sigma \\ \\vdash\\ \\texttt{f} ::_{\\uparrow} \\texttt{\\{} \\texttt{v}\\texttt{:}\\ \\sigma \\texttt{\\} -> } \\tau' \\\\ \\Gamma, \\sigma \\ \\vdash\\ \\texttt{x} ::_{\\downarrow} \\sigma \\\\ \\tau' \\bigl[\\texttt{v} \\mapsto \\texttt{x}\\bigr] \\Downarrow\\ \\tau' \\\\ \\hline \\Gamma, \\sigma \\ \\vdash\\ \\texttt{f\\{x\\}} ::_{\\uparrow} \\tau' \\end{array} which follows the regular application rule, and \\begin{array}{c} \\Gamma, \\sigma \\ \\vdash\\ \\texttt{f} ::_{\\uparrow} \\prod_i\\texttt{\\{} \\texttt{v}_i\\texttt{:}\\ \\sigma_i \\texttt{\\}.} \\texttt{ (v: }\\sigma\\texttt{) -> } \\tau \\\\ \\Gamma, \\sigma \\ \\vdash\\ \\texttt{x} ::_{\\uparrow} \\sigma' \\\\ I, S = \\text{unify(}\\sigma, \\sigma'\\text{)} \\\\ \\tau \\bigl[\\texttt{v} \\mapsto \\texttt{x}\\bigr] S \\Downarrow\\ \\tau' \\\\ \\hline \\Gamma, \\sigma \\ \\vdash\\ \\texttt{f(x)} ::_{\\uparrow} \\prod_{i \\in I}\\texttt{\\{v}_i\\texttt{: }\\sigma_i\\texttt{\\} -> }\\tau' \\end{array} which uses unification to solve for implicict arguments (and leaves uninferrable untouched out). That is, I is the set of variables which are left unsolved by \\text{unify} , and S is a substitution from implicit variables to the solved terms that unifies \\sigma' and \\sigma' . Evaluation The evaluation rules for the language extended to spreadsheets are equally simple. They abstract the recalculation using the context \\sigma introduced earlier and extends existing rules accordingly. The new rules become: \\begin{array}{c} \\sigma_V(\\textit{sheet-id}\\ \\textbf{!}\\ \\mathfrak{n}\\ \\mathfrak{m}) = v \\\\ \\hline \\sigma\\ \\vdash\\ \\textit{sheet-id}\\ \\textbf{!}\\ \\mathfrak{n}\\ \\mathfrak{m}\\ \\Downarrow\\ v \\end{array} \\begin{array}{c} \\sigma_V(\\textit{sheet-id}\\ \\textbf{!}\\ (i,j)) = v_{i,j} \\\\ \\hline \\sigma\\ \\vdash\\ \\textit{sheet-id}\\ \\textbf{!} \\ \\mathfrak{n}\\ \\mathfrak{m}\\ \\textbf{:}\\ \\mathfrak{n}'\\ \\mathfrak{m}' \\Downarrow\\ [ \\text{..} v_{i,j} ]_{ (i,j) \\in \\mathfrak{n}\\ \\mathfrak{m}\\ \\textbf{:}\\ \\mathfrak{n}'\\ \\mathfrak{m}' } \\end{array} (where \\text{..}\\_ flattens a tensor value and acts as an identity otherwise) Thus references to cell ranges behave as nested arrays with dependently typed sizes: Andres L\u00f6h, Conor McBride, Wouter Swierstra. A Tutorial Implementation of a Dependently Typed Lambda Calculus . \u21a9","title":"Core Language"},{"location":"core/#core-language-modulo-changes-new-features-and-bugs","text":"The provided core language (see Recalc.Language ) implements a simple, dependently typed functional programming language based on LambdaPi 1 , which is extended by cell references (sized, nested multi-dimensional arrays), and implicit arguments.","title":"Core Language (modulo changes, new features and bugs)"},{"location":"core/#syntax","text":"Cell references and ranges are similar to Excel: \\begin{aligned} \\mathfrak{m} \\ \\mathrel{::=} & 1 \\mid 2 \\mid \\dots \\\\ \\mathfrak{n} \\ \\mathrel{::=} & \\text{A} \\mid \\text{B} \\mid \\dots \\mid \\text{AA} \\mid \\dots \\\\ \\alpha \\ \\mathrel{::=} & \\ \\mathfrak{n}\\ \\mathfrak{m} \\mid \\mathfrak{n}\\ \\mathfrak{m}\\ \\textbf{:}\\ \\mathfrak{n}\\ \\mathfrak{m} \\\\ \\\\ \\textit{sheet-id} \\ \\mathrel{::=} & \\ \\textit{simple-sheet-name} \\\\ \\mid & \\ \\texttt{'} \\textit{sheet-name} \\texttt{'} \\\\ \\mid & \\ \\texttt{[}\\ \\textit{simple-uri}\\ \\texttt{]} \\textit{simple-sheet-name} \\\\ \\mid & \\ \\texttt{'[}\\ \\textit{uri}\\ \\texttt{]} \\textit{sheet-name} \\texttt{'} \\\\ \\\\ \\xi \\ \\mathrel{::=} & \\ \\Bigl[\\textit{sheet-id}\\ \\textbf{!}\\Bigr]\\ \\alpha \\end{aligned} Where \\textit{uri} and \\textit{sheet-name} must be printable, and characters '[]\\ need to be escaped with \\ . The corresponding \\textit{simple-} prefixed versions may only contain alphanumeric characters and ._~ . When \\textit{sheet-id} is not (or partially) provided, it is implicitly defined as the \\textit{uri} and/or \\textit{sheet-name} of the location where it is being read. Terms and types share the syntax of a standard lambda calculus with dependent functions: \\begin{array}{ll} \\text{f}, \\text{x}, \\sigma, \\tau & \\mathrel{::=} & \\textit{literal} & \\color{grey}{\\text{-- decimals and Boolean values}} \\\\ & \\mid & \\text{v} & \\color{grey}{\\text{-- variables}} \\\\ & \\mid & \\texttt{\\\\} \\text{v}\\ \\texttt{->}\\ \\text{x} & \\color{grey}{\\text{-- lambda abstraction}} \\\\ & \\mid & \\texttt{*} & \\color{grey}{\\text{-- kind of types}} \\\\ & \\mid & \\texttt{(} \\text{v}\\texttt{:}\\ \\sigma \\texttt{) -> } \\tau & \\color{grey}{\\text{-- dependent function type}} \\\\ & \\mid & \\texttt{\\{} \\text{v}\\texttt{:}\\ \\sigma \\texttt{\\} -> } \\tau & \\color{grey}{\\text{-- implicit dependent function type}} \\\\ & \\mid & \\xi & \\color{grey}{\\text{-- cell reference}} \\\\ & \\mid & \\text{f(x}_1, \\dots\\text{)} & \\color{grey}{\\text{-- application}} \\\\ & \\mid & \\text{f\\{x}_1, \\dots\\text{\\}} & \\color{grey}{\\text{-- explicit application of an implicit argument}} \\end{array} where \\textit{literal} includes signed decimals, int , bool , false , and true . Identifiers are case-insensitive. When a function type ignores its argument it can be written as \\sigma \\texttt{ -> } \\tau and similarly \\text{\\{}\\sigma\\text{\\}} \\texttt{ -> } \\tau for implicit arguments.","title":"Syntax"},{"location":"core/#typechecking-and-inference","text":"The typing judgements and evaluation rules follow directly the LambdaPi implementation (a simple bi-directional typechecker). The only notable difference is that we introduce another context \\sigma which gives the type \\sigma_T(\\xi) and value \\sigma_V(\\xi) of a cell. The original rules are trivially extended, passing the additional \\sigma around. For example, the rule \\small{\\text{CHK}} would be extended as follows: \\begin{array}{c} \\Gamma, \\sigma\\ \\vdash\\ e\\ ::_{\\uparrow}\\ \\tau \\\\ \\hline \\Gamma, \\sigma\\ \\vdash\\ e\\ ::_{\\downarrow}\\ \\tau \\end{array}","title":"Typechecking and Inference"},{"location":"core/#cell-references","text":"Rules concerning cell references and cell ranges make use of the new type constructor \\text{<}..\\text{>[}\\tau\\text{]} for tensors (not part of the surface language) and are quite simple: \\begin{array}{c} \\sigma_T(\\textit{sheet-id}\\ \\textbf{!}\\ \\mathfrak{n}\\ \\mathfrak{m}) = \\tau \\\\ \\hline \\Gamma, \\sigma\\ \\vdash\\ \\textit{sheet-id}\\ \\textbf{!}\\ \\mathfrak{n}\\ \\mathfrak{m}\\ ::_{\\uparrow}\\ \\tau \\end{array} \\begin{array}{c} \\sigma_T(\\textit{sheet-id}\\ \\textbf{!}\\ \\mathfrak{n}\\ \\mathfrak{m}) = \\tau \\\\ \\forall i j. (i,j) \\in \\mathfrak{n}\\ \\mathfrak{m}\\ \\textbf{:}\\ \\mathfrak{n}'\\ \\mathfrak{m}' \\implies \\sigma_T(\\textit{sheet-id}\\ \\textbf{!} (i,j)) = \\tau \\\\ m = \\mathfrak{m}' - \\mathfrak{m} \\land n = \\mathfrak{n}' - \\mathfrak{n} \\\\ dims = \\text{inferDimensions}(m, n, \\tau) \\\\ \\hline \\Gamma, \\sigma \\ \\vdash\\ \\textit{sheet-id}\\ \\textbf{!}\\ \\mathfrak{n}\\ \\mathfrak{m}\\ \\textbf{:}\\ \\mathfrak{n}'\\ \\mathfrak{m}' ::_{\\uparrow} \\text{<}dims\\text{>}\\lfloor\\tau\\rfloor \\end{array} The first one just states that a simple cell reference has the same type as the type of the term at that location. The second one is similar. Using the top left corner of a selection it makes sure that all cells in the referred range share that type \\tau . The type of a cell range is a tensor with elements \\lfloor\\tau\\rfloor . (where \\lfloor\\_\\rfloor is an identity for all types except tensor types \\text{<}..\\text{>[}\\tau'\\text{]} for which it is defined as \\tau' ) The dimensions of the resulting tensor are given by \\text{inferDimensions}(m,n,\\tau) \\mathrel{::=} \\begin{cases} n, \\text{dim}(\\tau) & \\text{if }m = 1, \\\\ m, \\text{dim}(\\tau) & \\text{if }n = 1, \\\\ m, n, \\text{dim}(\\tau) & \\text{otherwise}. \\end{cases} \\text{dim}(\\tau) \\mathrel{::=} \\begin{cases} \\bar{d} & \\text{if }\\tau\\text{ has shape <}\\bar{d}\\text{>[}\\tau'\\text{]}, \\\\ \\small{\\text{[ ]}} & \\text{otherwise}. \\end{cases} That is, referring to an m \\times n range of cells gives a tensor which potentially can become higher order when the elements are tensors by themselves.","title":"Cell References"},{"location":"core/#implicit-arguments","text":"Implicit arguments are covered by \\begin{array}{c} \\Gamma, \\sigma \\ \\vdash\\ \\texttt{f} ::_{\\uparrow} \\texttt{\\{} \\texttt{v}\\texttt{:}\\ \\sigma \\texttt{\\} -> } \\tau' \\\\ \\Gamma, \\sigma \\ \\vdash\\ \\texttt{x} ::_{\\downarrow} \\sigma \\\\ \\tau' \\bigl[\\texttt{v} \\mapsto \\texttt{x}\\bigr] \\Downarrow\\ \\tau' \\\\ \\hline \\Gamma, \\sigma \\ \\vdash\\ \\texttt{f\\{x\\}} ::_{\\uparrow} \\tau' \\end{array} which follows the regular application rule, and \\begin{array}{c} \\Gamma, \\sigma \\ \\vdash\\ \\texttt{f} ::_{\\uparrow} \\prod_i\\texttt{\\{} \\texttt{v}_i\\texttt{:}\\ \\sigma_i \\texttt{\\}.} \\texttt{ (v: }\\sigma\\texttt{) -> } \\tau \\\\ \\Gamma, \\sigma \\ \\vdash\\ \\texttt{x} ::_{\\uparrow} \\sigma' \\\\ I, S = \\text{unify(}\\sigma, \\sigma'\\text{)} \\\\ \\tau \\bigl[\\texttt{v} \\mapsto \\texttt{x}\\bigr] S \\Downarrow\\ \\tau' \\\\ \\hline \\Gamma, \\sigma \\ \\vdash\\ \\texttt{f(x)} ::_{\\uparrow} \\prod_{i \\in I}\\texttt{\\{v}_i\\texttt{: }\\sigma_i\\texttt{\\} -> }\\tau' \\end{array} which uses unification to solve for implicict arguments (and leaves uninferrable untouched out). That is, I is the set of variables which are left unsolved by \\text{unify} , and S is a substitution from implicit variables to the solved terms that unifies \\sigma' and \\sigma' .","title":"Implicit Arguments"},{"location":"core/#evaluation","text":"The evaluation rules for the language extended to spreadsheets are equally simple. They abstract the recalculation using the context \\sigma introduced earlier and extends existing rules accordingly. The new rules become: \\begin{array}{c} \\sigma_V(\\textit{sheet-id}\\ \\textbf{!}\\ \\mathfrak{n}\\ \\mathfrak{m}) = v \\\\ \\hline \\sigma\\ \\vdash\\ \\textit{sheet-id}\\ \\textbf{!}\\ \\mathfrak{n}\\ \\mathfrak{m}\\ \\Downarrow\\ v \\end{array} \\begin{array}{c} \\sigma_V(\\textit{sheet-id}\\ \\textbf{!}\\ (i,j)) = v_{i,j} \\\\ \\hline \\sigma\\ \\vdash\\ \\textit{sheet-id}\\ \\textbf{!} \\ \\mathfrak{n}\\ \\mathfrak{m}\\ \\textbf{:}\\ \\mathfrak{n}'\\ \\mathfrak{m}' \\Downarrow\\ [ \\text{..} v_{i,j} ]_{ (i,j) \\in \\mathfrak{n}\\ \\mathfrak{m}\\ \\textbf{:}\\ \\mathfrak{n}'\\ \\mathfrak{m}' } \\end{array} (where \\text{..}\\_ flattens a tensor value and acts as an identity otherwise) Thus references to cell ranges behave as nested arrays with dependently typed sizes: Andres L\u00f6h, Conor McBride, Wouter Swierstra. A Tutorial Implementation of a Dependently Typed Lambda Calculus . \u21a9","title":"Evaluation"},{"location":"development/","text":"Set up the Development Environment Open a dev shell: git clone git@github.com:b4er/recalc.git cd recalc/ nix develop Running Tests This will drop you into a shell with all necessary dependencies available where you can run the test suite: cabal test npm --prefix recalc-vscode run tests Running the Web Extension in Development In a dev shell open the current directory (eg. codium . ), launch the extension development host using (F5). Logging When running the extension open the Output view and select the recalc channel. You should see the logs there (you can set the Log Level in the Extension Settings). The Haskell backend uses stdout for JSON-RPC, but all output written to stderr will be forwarded to the Output channel mentioned earlier. When running the NPM tests manually, you can set the environment variable LOG_OUTPUT=true and it will write logs during the tests to a logfile.","title":"Development Guide"},{"location":"development/#set-up-the-development-environment","text":"Open a dev shell: git clone git@github.com:b4er/recalc.git cd recalc/ nix develop","title":"Set up the Development Environment"},{"location":"development/#running-tests","text":"This will drop you into a shell with all necessary dependencies available where you can run the test suite: cabal test npm --prefix recalc-vscode run tests","title":"Running Tests"},{"location":"development/#running-the-web-extension-in-development","text":"In a dev shell open the current directory (eg. codium . ), launch the extension development host using (F5).","title":"Running the Web Extension in Development"},{"location":"development/#logging","text":"When running the extension open the Output view and select the recalc channel. You should see the logs there (you can set the Log Level in the Extension Settings). The Haskell backend uses stdout for JSON-RPC, but all output written to stderr will be forwarded to the Output channel mentioned earlier. When running the NPM tests manually, you can set the environment variable LOG_OUTPUT=true and it will write logs during the tests to a logfile.","title":"Logging"},{"location":"frontend/","text":"Frontend (TypeScript) The frontend is implemented as a standard Web Extension : The Extension automatically starts whenever an *.rc file is opened, it starts a backend process (see recalc-vscode.serverUri configuration in configuration manifest) and establishes a communication channel. Each URI gets an associated Webview which is able to send URI-tagged messages to the backend, the entry-point for the frontend starts a Spreadsheet UI using the Univer Sheet API . Code Structure The project is a standard NPM project with esbuild.mjs as the build script. The frontend code is organized as a standard Univer plugin .","title":"Frontend"},{"location":"frontend/#frontend-typescript","text":"The frontend is implemented as a standard Web Extension : The Extension automatically starts whenever an *.rc file is opened, it starts a backend process (see recalc-vscode.serverUri configuration in configuration manifest) and establishes a communication channel. Each URI gets an associated Webview which is able to send URI-tagged messages to the backend, the entry-point for the frontend starts a Spreadsheet UI using the Univer Sheet API .","title":"Frontend (TypeScript)"},{"location":"frontend/#code-structure","text":"The project is a standard NPM project with esbuild.mjs as the build script. The frontend code is organized as a standard Univer plugin .","title":"Code Structure"},{"location":"install/","text":"Installing the Web Extension The easiest is installing the extension from the Visual Studio Marketplace: Installing from Source You can build the extension from source and then install it with: # set your editor (eg. EDITOR=codium) EDITOR=code version=\"$(jq -r .version < recalc-vscode/package.json)\" $EDITOR --install-extension \"result/recalc-vscode-${version}.vsix\" The Webview Extension should automatically start when opening a file ending with .rc .","title":"Installation"},{"location":"install/#installing-the-web-extension","text":"The easiest is installing the extension from the Visual Studio Marketplace:","title":"Installing the Web Extension"},{"location":"install/#installing-from-source","text":"You can build the extension from source and then install it with: # set your editor (eg. EDITOR=codium) EDITOR=code version=\"$(jq -r .version < recalc-vscode/package.json)\" $EDITOR --install-extension \"result/recalc-vscode-${version}.vsix\" The Webview Extension should automatically start when opening a file ending with .rc .","title":"Installing from Source"},{"location":"library/","text":"Library The backend components (recalculation engine, server routing and language implementation) are decoupled and can readily be re-used. Since there is only one actual frontend, the most common usage will be: import Recalc.Univer data Term = ... instance Recalc Term where -- language semantics instance UniverRecalc Term where -- error pretty-printing -- sheet-defined function handling (optional) main :: IO () main = univerMain @Term env0 Recalc The Recalc instance specifies how to parse formulas and values (simple terms), compute the dependencies of a term, infer types given the type(s) of other cells (using fetchType ), and evaluate a term (again given the values of other cells, this time using fetchValue ). For type inference there are two functions that can be implented, either infer or inferElaborate (only one should be defined). The latter is for type-directed elaboration and during type inference terms may be refined. UniverRecalc The UniverRecalc instance specifies how to display errors (by defining errorAnnotation ), and (optionally) how a sheet-defined function extends the environment. For concrete implementations refer to engine tests , or the core language implementation (described here ). The TypeScript frontend currently is not in a library form, the easiest will be to run the original extension and configure the language server (by setting recalc-vscode.serverUri in your settings.json ).","title":"As a Library"},{"location":"library/#library","text":"The backend components (recalculation engine, server routing and language implementation) are decoupled and can readily be re-used. Since there is only one actual frontend, the most common usage will be: import Recalc.Univer data Term = ... instance Recalc Term where -- language semantics instance UniverRecalc Term where -- error pretty-printing -- sheet-defined function handling (optional) main :: IO () main = univerMain @Term env0","title":"Library"},{"location":"library/#recalc","text":"The Recalc instance specifies how to parse formulas and values (simple terms), compute the dependencies of a term, infer types given the type(s) of other cells (using fetchType ), and evaluate a term (again given the values of other cells, this time using fetchValue ). For type inference there are two functions that can be implented, either infer or inferElaborate (only one should be defined). The latter is for type-directed elaboration and during type inference terms may be refined.","title":"Recalc"},{"location":"library/#univerrecalc","text":"The UniverRecalc instance specifies how to display errors (by defining errorAnnotation ), and (optionally) how a sheet-defined function extends the environment. For concrete implementations refer to engine tests , or the core language implementation (described here ). The TypeScript frontend currently is not in a library form, the easiest will be to run the original extension and configure the language server (by setting recalc-vscode.serverUri in your settings.json ).","title":"UniverRecalc"}]}