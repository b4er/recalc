{-# LANGUAGE TemplateHaskell #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}

module Main where

import Data.Aeson.TypeScript.TH

import Language.Haskell.TH
import Network.URI

import Recalc.Server
import Recalc.Server.Protocol
import Recalc.Server.TypeScript

instance TypeScript URI where
  getTypeScriptType _ = "string"

-- extract all ''*Param and ''*Return and @deriveTypeScript@ on it
$( reify ''SpreadsheetProtocol >>= \case
    TyConI (DataD _ _ _ _ [RecC _ tys] _) -> do
      let
        isDataOrNewtype = \case
          TyConI DataD{} -> True
          TyConI NewtypeD{} -> True
          _ -> False

        -- this is a bit annoying since we wouldn't want to rederive eg. Json.Value
        names =
          concat
            [ name : (case result of ConT r | nameModule r == Just "Recalc.Server.Protocol" -> [r]; _ -> [])
            | (_, _, AppT _ (AppT (AppT (AppT (ConT _) _) (ConT name)) result)) <- tys
            ]

      -- derive TypeScript for all newtypes and data defs
      foldMap (deriveTypeScript aesonOptions . fst)
        . filter (isDataOrNewtype . snd)
        . zip names
        =<< mapM reify names
    _ -> error "invalid Protocol type?"
 )

main :: IO ()
main = do
  putStrLn "/** this file is auto-generated by src/ts/Main.hs */\n"
  putStrLn . formatTSDeclarations $ typeScriptInterface @SpreadsheetProtocol
